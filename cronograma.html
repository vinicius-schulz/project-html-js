<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cronograma do Projeto Google CCAI Platform</title>
  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
  <script type="text/javascript">
    let tasks = [];

    google.charts.load('current', {
      'packages': ['gantt'],
      'language': 'pt-BR'
    });
    google.charts.setOnLoadCallback(drawChart);

    function drawChart() {
      if (tasks && tasks.length > 0) {
        var data = new google.visualization.DataTable();
        data.addColumn('string', 'Id da tarefa');
        data.addColumn('string', 'Nome da tarefa');
        data.addColumn('string', 'Recurso');
        data.addColumn('date', 'Data de Início');
        data.addColumn('date', 'Data Fim');
        data.addColumn('number', 'Duração');
        data.addColumn('number', 'Percentual completo');
        data.addColumn('string', 'Dependencias');

        tasks.forEach(task => {
          data.addRow([
            task.id,
            task.name,
            task.resource,
            new Date(task.start),
            new Date(task.end),
            null,
            task.percentComplete,
            task.dependencies ? task.dependencies : ''
          ]);
        });

        // Obtém a altura e largura do contêiner
        var container = document.getElementById('gantt_chart');
        var containerHeight = container.offsetHeight || window.innerHeight;  // Usar altura da janela caso não haja altura no contêiner
        var containerWidth = container.offsetWidth || window.innerWidth;     // Usar largura da janela caso não haja largura no contêiner

        var options = {
          height: containerHeight,  // Define altura do gráfico baseada no contêiner
          width: containerWidth,    // Define largura do gráfico baseada no contêiner
          gantt: {
            trackHeight: 30,  // Altura das barras das tarefas no gráfico (opcional)
            criticalPathEnabled: true,
            criticalPathStyle: {
              stroke: '#e64a19',
              strokeWidth: 5
            }
          }
        };

        var chart = new google.visualization.Gantt(container);
        chart.draw(data, options);
      }
    }

    function updateChart() {
      drawChart();
    }

    function addTask() {
      tasks.push({ id: '', name: '', resource: '', start: '', end: '', percentComplete: 0, dependencies: '' });
      renderTable();
      updateChart();
    }

    // Função para verificar se a tarefa é uma dependência de outras tarefas
    function isDependency(taskId) {
      const dependentTasks = tasks.filter(task => task.dependencies && task.dependencies.includes(taskId));
      return dependentTasks;
    }

    // Função para remover uma tarefa com verificação de dependências
    function deleteTask(index) {
      const taskId = tasks[index].id;

      // Se a tarefa não tem ID, permitir exclusão
      if (!taskId) {
        tasks.splice(index, 1);
        renderTable();
        updateChart();
        return;
      }

      const dependentTasks = isDependency(taskId);

      if (dependentTasks.length > 0) {
        // Lista as tarefas que dependem da tarefa que se quer excluir
        const taskNames = dependentTasks.map(task => task.name).join(', ');
        alert(`A tarefa ${taskId} é uma dependência das seguintes tarefas: ${taskNames}. Não é possível excluí-la.`);
        return; // Impede a exclusão
      }

      // Caso não seja dependência de outra tarefa, exclui normalmente
      tasks.splice(index, 1);
      renderTable();
      updateChart();
    }




    function renderTable() {
      const tableBody = document.getElementById('task_table_body');
      tableBody.innerHTML = ''; // Limpa a tabela
      tasks.forEach((task, index) => {
        // Calcula o número de dias entre a data de início e fim da tarefa
        const days = task.start && task.end ? calculateDaysBetween(task.start, task.end) : '';

        const currentDate = new Date().toISOString().split('T')[0]; // Data atual no formato YYYY-MM-DD
        const endDate = task.end ? new Date(task.end).toISOString().split('T')[0] : null; // Data de fim no formato YYYY-MM-DD
        const percentCompleteReal = task.percentCompleteReal || 0; // Valor do percentual real, padrão é 0 se não informado

        let rowColor = ''; // Define a cor da linha

        // Verifica as condições para a cor da linha
        if (percentCompleteReal == 100) {
          rowColor = 'background-color: lightgreen;'; // Linha verde para 100%
        } else if (new Date(currentDate) > new Date(endDate)) {
          rowColor = 'background-color: lightpink;'; // Linha rosa claro se ultrapassou a data final e não está 100%
        } else if (currentDate === endDate) {
          rowColor = 'background-color: lightyellow;'; // Linha amarela se for a data final e não está 100%
        } else {
          rowColor = ''; // Manter linha branca
        }

        // Criação da linha da tabela com a cor condicional
        const row = `
      <tr style="${rowColor}" draggable="true" ondragstart="dragStart(event, ${index})" ondragover="dragOver(event)" ondrop="drop(event, ${index})">
        <td><input type="text" value="${task.id}" onblur="updateTask(${index}, 'id', this.value)" /></td>
        <td><input type="text" value="${task.name}" onblur="updateTask(${index}, 'name', this.value)" /></td>
        <td><input type="text" value="${task.resource}" onblur="updateTask(${index}, 'resource', this.value)" /></td>
        <td><input type="date" value="${task.start}" onblur="updateTask(${index}, 'start', this.value)" /></td>
        <td><input type="date" value="${task.end}" onblur="updateTask(${index}, 'end', this.value)" /></td>
        <td>${days}</td> <!-- Nova coluna que mostra o número de dias -->
        <td><input type="number" value="${task.percentComplete}" disabled/></td> <!-- Percentual completo não editável -->
        <td><input type="number" value="${percentCompleteReal}" onblur="updateTask(${index}, 'percentCompleteReal', this.value)" /></td> <!-- Nova coluna para Percentual Completo Real -->
        <td><input type="text" value="${task.dependencies || ''}" onblur="updateTask(${index}, 'dependencies', this.value)" /></td>
        <td>
          <button onclick="deleteTask(${index})">Excluir</button>
          <button onclick="adjustTask(${index})">Ajustar</button>
        </td>
      </tr>
    `;
        tableBody.innerHTML += row;
      });
    }




    function updateTask(index, field, value) {
      const oldValue = tasks[index][field]; // Valor antigo para comparação

      if (field === 'dependencies') {
        const dependencies = value.split(',').map(dep => dep.trim());
        const invalidDependencies = dependencies.filter(dep => !tasks.some(task => task.id === dep));

        if (invalidDependencies.length > 0) {
          alert(`As seguintes dependências são inválidas: ${invalidDependencies.join(', ')}`);
          tasks[index][field] = oldValue;
          renderTable();
          return;
        }
      }

      if (field === 'end') {
        tasks[index][field] = value;
        adjustDependentTasks(index);
      } else if (field === 'id' && value !== oldValue) {
        const oldId = oldValue;
        tasks[index][field] = value;

        tasks.forEach((task) => {
          if (task.dependencies) {
            const dependencies = task.dependencies.split(',');
            const updatedDependencies = dependencies.map(dep => dep.trim() === oldId ? value : dep.trim());
            task.dependencies = updatedDependencies.join(', ');
          }
        });
      } else if (field === 'percentCompleteReal') {
        const numValue = Number(value.trim());
        if (isNaN(numValue) || numValue < 0 || numValue > 100) {
          alert('Por favor, insira um número válido entre 0 e 100 para o percentual completo real.');
          return;
        }
        tasks[index][field] = numValue;  // Atualiza o Percentual Completo Real
      } else {
        tasks[index][field] = value.trim();
      }

      renderTable();
      updateChart();
    }



    // Função para ajustar a data das tarefas dependentes de forma recursiva
    function adjustDependentTasks(taskIndex) {
      const task = tasks[taskIndex];
      const taskEndDate = new Date(task.end);

      tasks.forEach((dependentTask, index) => {
        if (dependentTask.dependencies && dependentTask.dependencies.includes(task.id)) {
          const dependentTaskStartDate = new Date(dependentTask.start);

          // Se a data de início da tarefa dependente for menor ou igual à nova data de fim da tarefa principal
          if (dependentTaskStartDate <= taskEndDate) {
            const taskDuration = calculateDaysBetween(dependentTask.start, dependentTask.end); // Calcula a duração original

            // Ajusta a nova data de início e fim da tarefa dependente
            const newStartDate = new Date(taskEndDate.getTime() + (24 * 60 * 60 * 1000)); // Um dia após a data de fim da tarefa principal
            const newEndDate = new Date(newStartDate.getTime() + (taskDuration * 24 * 60 * 60 * 1000)); // Mantém a duração

            dependentTask.start = newStartDate.toISOString().split('T')[0];
            dependentTask.end = newEndDate.toISOString().split('T')[0];

            // Chama recursivamente para ajustar as tarefas que dependem dessa tarefa
            adjustDependentTasks(index);
          }
        }
      });
    }





    function exportTasks() {
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(tasks, null, 2));
      const downloadAnchorNode = document.createElement('a');
      downloadAnchorNode.setAttribute("href", dataStr);
      downloadAnchorNode.setAttribute("download", "tasks.json");
      document.body.appendChild(downloadAnchorNode);
      downloadAnchorNode.click();
      downloadAnchorNode.remove();
    }

    // Função para importar o JSON
    function importTasks(event) {
      const file = event.target.files[0];
      if (!file) return; // Se nenhum arquivo foi selecionado, não faz nada

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const importedTasks = JSON.parse(e.target.result);

          // Verifica se o arquivo contém uma lista de tarefas válida
          if (Array.isArray(importedTasks)) {
            tasks = importedTasks; // Sobrescreve a lista de tarefas com o novo arquivo
            renderTable(); // Re-renderiza a tabela com as novas tarefas
            updateChart(); // Atualiza o gráfico com as novas tarefas
          } else {
            alert('O arquivo não contém uma lista válida de tarefas.');
          }
        } catch (error) {
          alert('Erro ao ler o arquivo. Verifique o formato do arquivo e tente novamente.');
        }
      };
      reader.readAsText(file);

      // Reseta o campo de arquivo após o carregamento
      event.target.value = ''; // Isso permite que o mesmo arquivo seja carregado novamente se necessário
    }



    let draggedTaskIndex = null;

    function dragStart(event, index) {
      draggedTaskIndex = index;
    }

    function dragOver(event) {
      event.preventDefault();
    }

    function drop(event, dropIndex) {
      event.preventDefault();
      if (draggedTaskIndex !== null) {
        const draggedTask = tasks[draggedTaskIndex];
        tasks.splice(draggedTaskIndex, 1);
        tasks.splice(dropIndex, 0, draggedTask);
        draggedTaskIndex = null;
        renderTable();
        updateChart();
      }
    }

    // Função para ajustar a data de uma tarefa
    function adjustTask(index) {
      const newDate = prompt('Digite a nova data de início (formato YYYY-MM-DD):');
      if (newDate) {
        const oldStart = new Date(tasks[index].start);
        const newStart = new Date(newDate);
        const diff = newStart - oldStart; // Diferença em milissegundos
        tasks[index].start = newStart.toISOString().split('T')[0];
        const oldEnd = new Date(tasks[index].end);
        const newEnd = new Date(oldEnd.getTime() + diff); // Ajusta a data de fim
        tasks[index].end = newEnd.toISOString().split('T')[0];

        // Recalcular datas das tarefas dependentes
        adjustDependencies(index, diff);

        renderTable();
        updateChart();
      }
    }

    // Função para ajustar as datas de tarefas dependentes
    function adjustDependencies(taskIndex, diff) {
      const task = tasks[taskIndex];
      tasks.forEach((dependentTask, index) => {
        if (dependentTask.dependencies && dependentTask.dependencies.includes(task.id)) {
          const start = new Date(dependentTask.start);
          const end = new Date(dependentTask.end);

          // Ajusta as datas de início e fim
          dependentTask.start = new Date(start.getTime() + diff).toISOString().split('T')[0];
          dependentTask.end = new Date(end.getTime() + diff).toISOString().split('T')[0];

          // Chama recursivamente para ajustar os dependentes dessa tarefa
          adjustDependencies(index, diff);
        }
      });
    }

    // Função para calcular a diferença entre duas datas em dias
    function calculateDaysBetween(startDate, endDate) {
      const start = new Date(startDate);
      const end = new Date(endDate);
      const diffTime = Math.abs(end - start); // Diferença em milissegundos
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); // Converter milissegundos para dias
      return diffDays;
    }


    window.onload = function () {
      renderTable();
    }
  </script>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #gantt_chart {
      height: 100vh;
      /* O gráfico vai ocupar 100% da altura da janela */
      width: 100vw;
      /* O gráfico vai ocupar 100% da largura da janela */
    }

    tr:hover {
      background-color: #f0f0f0;
      /* Cor de fundo ao passar o mouse */
    }

    table input {
      background-color: transparent;
      border: none;
      outline: none;
      pointer-events: none;
      /* Impede a interação enquanto o mouse está sobre a linha */
    }

    tr:hover input {
      pointer-events: auto;
      /* Permite interação com os inputs ao passar o mouse */
    }

    table input[type="text"]::placeholder {
      color: black;
      /* Define a cor do placeholder como preto, para que ele se destaque se necessário */
    }

    table input[type="date"] {
      color: black;
    }

    table input[type="number"] {
      color: black;
    }

    table {
      width: 100%;
      table-layout: auto;
      border-collapse: collapse;
      /* Remove o espaço entre as células */
    }

    th {
      resize: horizontal;
      /* Permite o redimensionamento horizontal */
      overflow: hidden;
      /* Garante que o conteúdo que exceder o tamanho da célula seja ocultado */
      padding: 8px;
    }

    td {
      padding: 8px;
    }

    th,
    td {
      text-align: left;
    }

    input,
    select {
      width: 100%;
      /* Faz com que o input ocupe 100% do espaço da célula */
      box-sizing: border-box;
      /* Garante que o padding seja incluído no tamanho total do input */
      background-color: transparent;
      /* Define o fundo transparente */
      border: none;
      /* Remove a borda dos inputs */
    }

    tr[draggable="true"] {
      cursor: move;
    }
  </style>
</head>

<body>


  <h2>Tarefas</h2>
  <button onclick="addTask()">Adicionar Tarefa</button>
  <button onclick="exportTasks()">Exportar JSON</button>
  <input type="file" id="fileInput" accept=".json" onchange="importTasks(event)" />

  <table style="width: 100%; margin-top: 10px;">
    <thead>
      <tr>
        <th>Id da tarefa</th>
        <th>Nome da tarefa</th>
        <th>Recurso</th>
        <th>Data de Início</th>
        <th>Data Fim</th>
        <th>Dias</th>
        <th>Percentual completo</th> <!-- Coluna antiga, agora não editável -->
        <th>Percentual completo real</th> <!-- Nova coluna -->
        <th>Dependências</th>
        <th>Ações</th>
      </tr>
    </thead>

    <tbody id="task_table_body"></tbody>
  </table>

  <h1>Cronograma</h1>
  <div id="gantt_chart" style="height: 100%; width: 100%;"></div>
</body>


</html>